{"meta":{"title":"chen","subtitle":"","description":"","author":"chen","url":"https://chen28176.github.io","root":"/"},"pages":[{"title":"分类","date":"2023-05-29T17:43:39.000Z","updated":"2023-05-29T18:09:52.096Z","comments":true,"path":"categories/index.html","permalink":"https://chen28176.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"项目难点二，动态菜单","slug":"递归组件","date":"2023-06-17T05:00:00.000Z","updated":"2023-06-17T08:28:14.579Z","comments":true,"path":"2023/06/17/递归组件/","link":"","permalink":"https://chen28176.github.io/2023/06/17/%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一，概念实际开发项目中有很多的路由页面，所以动态菜单不能写死，应该更加灵活的渲染，让路由来决定菜单有多少，这里使用了递归组件进行递归组件是一种的组件，他在自身模板中调用自己，这种结构组件可以说很方便地处理具有嵌套层次关系的数据。 常见应用场景 数状结构展示:递归组件可以用来展示树状结构的数据，比如文件结构，评论列表等，通过递归组件调用自身，可以很容易地处理多层嵌套的数据，使得代码更加简洁清晰。 无限滚动列表：当需要实现一个无线滚动列表时，通过递归地渲染每一行数据，可以实现不断加载数据并展示在列表中的效果，提供更好的用户体验。 导航菜单：对于导航菜单中的多级菜单，通过递归地渲染每个菜单项以及它们的子菜单，可以实现动态生成多级导航菜单的功能 二，实现思路准备 创建菜单单项组件：定义一个用于显示单独菜单项的组件 定义菜单数据结构：创建一个存储菜单数据的数据结构，包括唯一标识和子菜单项 创建递归组件：在组件的template中使用组件自身，用于渲染多级菜单 处理递归终止的条件：定义递归终止的条件，例如当菜单项没有子菜单项时停止递归。 渲染菜单：在父组件中使用递归组件并传递菜单数据，来动态生成整个菜单 开始 将路由信息进行暴露 123456789101112131415export const constantRoute = [ &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/login/index.vue&#x27;), name: &#x27;login&#x27;, meta: &#123; title: &#x27;登录&#x27;, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: &#x27;Promotion&#x27;, //菜单文字左侧的图标,支持element-plus全部图标 &#125;, &#125;, &#123; ... &#125;] 接着创建pinia仓库, 引入路由信息 1234567891011121314151617 import &#123; constantRoute, asnycRoute, anyRoute &#125; from &#x27;@/router/routes&#x27; ``` - 创建用户小仓库，并在仓库中添加存储生成菜单需要的数组路由 menuRoutes ```javascript //创建用户小仓库 const useUserStore = defineStore(&#x27;User&#x27;, &#123; //小仓库存储数据地方 state: (): UserState =&gt; &#123; return &#123; token: GET_TOKEN(), //用户唯一标识token menuRoutes: constantRoute, //仓库存储生成菜单需要数组(路由) username: &#x27;&#x27;, avatar: &#x27;&#x27;, //存储当前用户是否包含某一个按钮 buttons: [], &#125;, &#125;, &#125;, 接着在引入到vue页面中 1import userUserStore from &#x27;@/store/modules/user&#x27; 引入组件并进行父子传递 1234import Menu from &#x27;./menu/index.vue&#x27; &lt;!-- 根据路由动态生成菜单 --&gt;&lt;Menu :menuList=&quot;userStore.menuRoutes&quot;&gt;&lt;/Menu&gt; 来到子组件页面，接受组件传递的信息 123&lt;Menu :menuList=&quot;item.children&quot;&gt;&lt;/Menu&gt;//获取父组件传递过来的全部路由数组defineProps([&#x27;menuList&#x27;]) 接着便是渲染菜单了，一般有三种情况 1，没有子菜单则直接渲染 –没有子路由 2，有子菜单 – 有子路由但是只有一个子路由 3，循环渲染子菜单时要判断是否又包含子菜单，如果包含则调用自身组件递归渲染 – 有子路由且个数大于1 前两个使用了v-if 第三个使用了递归组件 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;template v-for=&quot;(item, index) in menuList&quot; :key=&quot;item.path&quot;&gt; &lt;!--没有子路由--&gt; &lt;template v-if=&quot;!item.children&quot;&gt; &lt;el-menu-item :index=&quot;item.path&quot; v-if=&quot;!item.meta.hidden&quot; @click=&quot;goRoute&quot; &gt; &lt;el-icon&gt; &lt;component :is=&quot;item.meta.icon&quot;&gt;&lt;/component&gt; &lt;/el-icon&gt; &lt;template #title&gt; &lt;span&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;!-- 有子路由但是只有一个子路由 --&gt; &lt;template v-if=&quot;item.children &amp;&amp; item.children.length == 1&quot;&gt; &lt;el-menu-item :index=&quot;item.children[0].path&quot; v-if=&quot;!item.children[0].meta.hidden&quot; @click=&quot;goRoute&quot; &gt; &lt;el-icon&gt; &lt;component :is=&quot;item.children[0].meta.icon&quot;&gt;&lt;/component&gt; &lt;/el-icon&gt; &lt;template #title&gt; &lt;span&gt;&#123;&#123; item.children[0].meta.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;!-- 有子路由且个数大于一个1 --&gt; &lt;el-sub-menu :index=&quot;item.path&quot; v-if=&quot;item.children &amp;&amp; item.children.length &gt; 1&quot; &gt; &lt;template #title&gt; &lt;el-icon&gt; &lt;component :is=&quot;item.meta.icon&quot;&gt;&lt;/component&gt; &lt;/el-icon&gt; &lt;span&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;Menu :menuList=&quot;item.children&quot;&gt;&lt;/Menu&gt; &lt;/el-sub-menu&gt; &lt;/template&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useRouter &#125; from &#x27;vue-router&#x27;//获取父组件传递过来的全部路由数组defineProps([&#x27;menuList&#x27;])//获取路由器对象let $router = useRouter()//点击菜单的回调const goRoute = (vc: any) =&gt; &#123; //路由跳转 $router.push(vc.index)&#125;&lt;/script&gt;&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#x27;Menu&#x27;,&#125;&lt;/script&gt; 这里写了第二个script 进行循环嵌套 12345&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#x27;Menu&#x27;,&#125;&lt;/script&gt; 并在页面中调用自己 123456789&lt;el-sub-menu :index=&quot;item.path&quot; v-if=&quot;item.children &amp;&amp; item.children.length &gt; 1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt; &lt;component :is=&quot;item.meta.icon&quot;&gt;&lt;/component&gt; &lt;/el-icon&gt; &lt;span&gt;&#123;&#123; item.meta.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;Menu :menuList=&quot;item.children&quot;&gt;&lt;/Menu&gt; &lt;/el-sub-menu&gt; 当进入前两个条件不满足是，会去到第三个进行递归 ,无限递归","categories":[{"name":"后台管理项目","slug":"后台管理项目","permalink":"https://chen28176.github.io/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"跃动青春","slug":"跃动青春","date":"2023-05-30T12:00:00.000Z","updated":"2023-06-22T10:27:44.822Z","comments":true,"path":"2023/05/30/跃动青春/","link":"","permalink":"https://chen28176.github.io/2023/05/30/%E8%B7%83%E5%8A%A8%E9%9D%92%E6%98%A5/","excerpt":"","text":"跃动青春简介：岩仓美津未从乡下的小初中，以第一名的成绩考入了东京的高升学率高中。这位乡村神童心怀完美的人生蓝图、独自来到东京。她成绩优异，却与他人有着独特的距离感，稍显格格不入。她虽然偶尔会失败，但还是凭借天真的性格一点点打动班上的同学，使他们那各不相同的性格逐渐交叠。相遇、相知、最终心意相通。人人都会有心烦和焦躁之时。而无可替代的朋友，定将带来互相理解的契机。这是个偶有杂音却能让人不知不觉快乐起来的校园生活喜剧！ 在空闲时间观看了三集后发现这是一部相当治愈的番剧，就是一种很日常很日常，看着很舒服， 在这个网络抽象，精神病盛行的当下，能有这么治愈这么青春的动画，真的非常难得啊 漫改 日常 校园 治愈 推荐指数：⭐⭐⭐⭐⭐","categories":[{"name":"番剧推荐","slug":"番剧推荐","permalink":"https://chen28176.github.io/categories/%E7%95%AA%E5%89%A7%E6%8E%A8%E8%8D%90/"}],"tags":[]},{"title":"项目难点1","slug":"后台管理笔记 -- 动态菜单的实现","date":"2023-05-30T10:00:00.000Z","updated":"2023-05-29T18:16:03.115Z","comments":true,"path":"2023/05/30/后台管理笔记 -- 动态菜单的实现/","link":"","permalink":"https://chen28176.github.io/2023/05/30/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%20--%20%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1,动态菜单概念💡项目中菜单不能写死，应该灵活运用，根据路由的规格进行渲染到页面，也就是路由有几个页面上的菜单也应该有几个 2,实现1.将路由信息打包丢尽pinia仓库对外暴露配置路由(常量路由):全部用户都可以访问到的路由 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export const constantRoute = [ &#123; //登录 path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/login/index.vue&#x27;), name: &#x27;login&#x27;, meta: &#123; title: &#x27;登录&#x27;, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: &#x27;Promotion&#x27;, //菜单文字左侧的图标,支持element-plus全部图标 &#125;, &#125;, &#123; //登录成功以后展示数据的路由 path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/layout/index.vue&#x27;), name: &#x27;layout&#x27;, meta: &#123; title: &#x27;&#x27;, hidden: false, icon: &#x27;&#x27;, &#125;, redirect: &#x27;/home&#x27;, children: [ &#123; path: &#x27;/home&#x27;, component: () =&gt; import(&#x27;@/views/home/index.vue&#x27;), meta: &#123; title: &#x27;首页&#x27;, hidden: false, icon: &#x27;HomeFilled&#x27;, &#125;, &#125;, ], &#125;, &#123; //404 path: &#x27;/404&#x27;, component: () =&gt; import(&#x27;@/views/404/index.vue&#x27;), name: &#x27;404&#x27;, meta: &#123; title: &#x27;404&#x27;, hidden: true, icon: &#x27;DocumentDelete&#x27;, &#125;, &#125;, // &#123; // path: &#x27;/screen&#x27;, // component: () =&gt; import(&#x27;@/views/screen/index.vue&#x27;), // name: &#x27;Screen&#x27;, // meta: &#123; // hidden: false, // title: &#x27;数据大屏&#x27;, // icon: &#x27;Platform&#x27;, // &#125;, // &#125;,] 将导出路由的信息传递到pinia仓库里面 1import &#123; constantRoute &#125; from &#x27;@/router/routes&#x27; pinia仓库：user.ts 文件 12345678910111213141516171819202122232425262728293031//引入路由(常量路由)import &#123; constantRoute &#125; from &#x27;@/router/routes&#x27;const useUserStore = defineStore(&#x27;User&#x27;, &#123; state: (): UserState =&gt; &#123; return &#123; token: GET_TOKEN(), //用户唯一标识token menuRoutes: constantRoute, //存储仓库 &#125; &#125;, actions: &#123; async userLogin(data: loginForm) &#123; // 登录请求 const result: loginResponseDate = await reqLogin(data) // 登录成功pinia仓库存储一下token if (result.code == 200) &#123; //pinia 仓库存储一下token //由于pinia vuex 存储数据其实利用js对象 刷新页面回丢失数据 需要持久化存储可以使用本地存储 //或者可以使用pinia vuex 持久化插件 this.token = result.data.token as string //本地存储持久化存储一份 localStorage.setItem(&#x27;TIKEN&#x27;, result.data.token as string) return &#x27;ok&#x27; &#125; else &#123; return Promise.reject(new Error(result.data.message)) &#125; &#125;, &#125;, getters: &#123;&#125;,&#125;)//导出export default useUserStore 2.通过父子传参传递路由信息父组件引入pinia仓库数据 123//获取用户相关的小仓库import userUserStore from &#x27;@/store/modules/user&#x27;let userStore = userUserStore() 拿到userStore后传给子组件 1&lt;Menu :menuList=&quot;userStore.menuRoutes&quot;&gt;&lt;/Menu&gt; 子组件接收 12//获取父组件传递过来的全部路由数组defineProps([&#x27;menuList&#x27;]) 3.根据该路由数组动态生成菜单（递归组件）在最外层进行遍历 12&lt;template v-for=&quot;(item, index) in menuList&quot; :key=&quot;item.path&quot;&gt;&lt;/template&gt; 子组件接收后遍历到页面中，由于路由有些有子路由元素，有些没有，所以遍历时进行了三个判断 第一个 : 没有子路由 123456789&lt;!-- 没有子路由 --&gt; &lt;el-menu-item v-if=&quot;!item.children&quot;&gt; &lt;template #title&gt; &lt;span&gt;1&amp;nbsp;&lt;/span&gt; &lt;span&gt; &#123;&#123; item.meta.title &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; 第二个：有子路由但是只有一个子路由 :index&#x3D;”item.children[0].path” 此处为确定唯一标识 123456&lt;!-- 有子路由但是只有一个子路由 --&gt; &lt;el-menu-item :index=&quot;item.children[0].path&quot; v-if=&quot;item.children &amp;&amp; item.children.length == 1&quot;&gt; &lt;template #title&gt; &lt;span&gt;&#123;&#123; item.children[0].title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; 第三个：有子路由且个数大于一 递归组件:程序调用自身称为递归 1234567891011121314151617 &lt;el-sub-menu :index=&quot;item.path&quot; v-if=&quot;item.children &amp;&amp; item.children.length &gt; 1&quot;&gt; &lt;template #title&gt; &lt;span&gt; &#123;&#123; item.meta.title &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;Menu :menuList=&quot;item.children&quot;&gt;&lt;/Menu&gt;&lt;/el-sub-menu&gt;&lt;script setup lang=&quot;ts&quot;&gt;//获取父组件传递过来的全部路由数组defineProps([&#x27;menuList&#x27;])&lt;/script&gt;&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#x27;Menu&#x27;,&#125;&lt;/script&gt; 4,移除不需要遍历到页面的路由（有些路由不需要遍历到页面，比如登录组件，404组件）可以在路由元信息里添加是否需要隐藏的参数 hidden: true 1234567891011&#123; //登录 path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;@/views/login/index.vue&#x27;), name: &#x27;login&#x27;, meta: &#123; title: &#x27;登录&#x27;, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: &#x27;Promotion&#x27;, //菜单文字左侧的图标,支持element-plus全部图标 &#125;,&#125;, 接着在页面进行判断(在判断条件外再添加一层template 双重if判断) 以此类推 1234567891011&lt;template v-if=&quot;!item.children&quot;&gt; &lt;!-- 如果hidden为false则不显示该组件 --&gt; &lt;el-menu-item v-if=&quot;!item.meta.hidden&quot;&gt; &lt;template #title&gt; &lt;span&gt;1&amp;nbsp;&lt;/span&gt; &lt;span&gt; &#123;&#123; item.meta.title &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/template&gt; 第三个无需过滤,递归的时候会进行过滤","categories":[{"name":"后台管理项目","slug":"后台管理项目","permalink":"https://chen28176.github.io/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"web竞赛的一些经验（前端）","slug":"心得体会","date":"2023-05-29T17:35:00.000Z","updated":"2023-05-29T18:12:41.014Z","comments":true,"path":"2023/05/30/心得体会/","link":"","permalink":"https://chen28176.github.io/2023/05/30/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/","excerpt":"","text":"赛前准备👌 需要具备的基本技术 vue： 比赛拿到的项目里移动端项目为vue2技术，而pc端项目为vue3项目，学会vue2后vue3基本可以在一个月之内简单上手 vuex ：状态管理模式，比赛项目是有用到的，但是占比很少，如若学习时间不够，那能看懂就行了。比赛时间太少了还没用到就结束了 axios：💡要求掌握,网络封装请求库，比赛项目百分百会使用到。 vant element-ui：这两个是组件库来自用于搭建页面，基本会一个另外一个也会使用了，比赛会部署到服务器上使用，选手在桌面点击他的一个命令窗口后弹出cmd窗口。等它执行完毕，在浏览器输入文档中的地址即可访问 手写商城项目 即便有试题，需要短时间学会很难，所以建议是看视频写一个vue的商城 注意使用到的技术需要与试题的一样。 vue2与vuex这两种基本已经停止更新了，不知道比赛方还会不会使用到，所以写的项目用的技术尽量与试题要求的技术一样。 阅读能力 拿到项目后里面一堆奇奇怪怪的目录，所以要求有一定的阅读能力。 需要你到用户页面操作答题。建议第一时间去router（路由文件夹）查看,里面会有各个页面的注释。 建议，学完vue后可以去找一下商城项目进行阅读熟悉，看多了就对哪个目录有什么文件一目了然了 进入考场 考场准备 会有时间给你检查设备的，那天比赛别的组出现过键盘无法使用的情况，另外那边屏幕太差了，看的眼睛痛 拿到文件袋，文件袋里面有个表，表里面的内容就是填写检查的设备是否完好之类的，还有u盘，笔，草稿纸。 会有人会说u盘的解压密码，选手把解压密码写到草稿纸即可。 u盘传输每秒只有100kb左右所以比赛快结束的时候预留充分的时间，整个商城项目是非常大的，做完的时候打包一个改项目后提交 开始抽试卷，一共有三道，我们那天比赛抽到的是a卷。 💡u盘目录有两个文件夹 1231.代码提交区 用于把打包后的代码提交到上面2,竞赛内容区 原型设计书，三个压缩包，一个移动端，一个pc，一个后端，另外其他的不重要也就没细细看了 💡注意，检查软件的时候建议就把后端项目跑起来，第一时间把后端项目跑起来，避免出现前端跑起来而拿不到数据的情况 vue2与vue3 如果你不是很熟悉vue3,不要慌，它整个商城项目是写好的了，你不知道具体格式是什么，就去别的vue文件看看。就比如我不知道获取接口，然后我跑到其他页面，看到他们是怎么操作接口的，我也就照猫画虎整了一个 排错详解 三道题。较为简单，可惜我时间花费比预计的长了一点，排错能力没问题，但是阅读能力太差了我。 印象不深刻就讲述一些记住的地方 ，可以理解为每道题5分，每道题有五个空 &#x3D;&#x3D;第一个是&#x3D;&#x3D; 要你把商品固定成一行两列，然后点击全选按钮其他产品会全选到。 全选按钮方法已经自带了，所以只要在全选按钮那里绑定点击事件即可 @click 固定成一行两列我一开始以为是flex布局，后面又用了网格布局，然后还是无法实现。最后花了几分钟在vant文档找到了解决方法 1默认一行展示四个格子，可以通过 column-num 自定义列数。 123&lt;van-grid :column-num=&quot;3&quot;&gt; &lt;van-grid-item v-for=&quot;value in 6&quot; :key=&quot;value&quot; icon=&quot;photo-o&quot; text=&quot;文字&quot; /&gt;&lt;/van-grid&gt; 只需要在加入：column-num来控制列数，所以整个试卷没有考到css，这点是我大意了，终究是我对vant不够熟悉才产生的难点 第二个是 订单的增删改查功能 如图所示，上述代码中购物车里的几个红全是静态的没有数据，而点击了也没有交互 而我们要做的就是把购物车里的页面的静态数据替换成动态的，相当简单，算是送分题目。 数据已经有了，方法也已经有了，所以只需要拿他们提供的数据渲染到页面，方法绑定到按钮上即可 第三个是地址列表功能 要求默认必须只能一个， 点击编辑跳转到联系人页，姓名，电话，地区，详细地址，需要检验，邮政编码 设为默认收获地址无需校验，送分题 三个排错题目较为简单能拿8分以上算优秀，代码注释太少，还是需要考验阅读能力 程序编码 &#x3D;&#x3D;注意比赛的时候题目不可能和我写的一模一样。&#x3D;&#x3D; 由于我负责的是移动端项目，时间没有分配好，所以导致开发的时候只有两个小时左右不到的时间程序编码。很遗憾就做了两个还是半成品 题目一 会提供接口给我们，我们需要根据接口进行操作。 我一开始就是axios获取数据，点击商品详细的时候会附带对于的id， 接着我们拿到id后到去请求对应的数据，拿到数据后进行渲染操作，这个可以用vant速搭。 点击加入购物车后会弹出一个框也是需要搭建一下 点击进入商品详细，加入购物车，没有一点代码，全是要靠自己去使用组件库vant搭建 1这个就仅仅占了一题，一共十题，所以正常比赛中，两个人能做完5题就已经很一等奖打招呼了 最后搭建我购物车，准备做数据交互的时候，发现时间不够了，于是我和同伴说，不要做数据交互了，把页面搭建起来比较容易拿分， 所以我开始做了第二个 第二题 第二题和第一题有联系的， 第一题的详情页搭建好了后，在详情页点击加入购物车跳转到购物车页面 第二题要的就是你搭建购物车页面，并且购物车要能够增删操作，并且点击下单后会跳转到订单支付页面，也是需要搭建的， 购物车的产品大概是这样 向右滑动可删除 底部长这样 （黄色那段字，原本是向右滑动可删除商品） 订单支付页面大概长这样","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"https://chen28176.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"平台部署","slug":"聚合搜索平台项目部署","date":"2023-05-23T10:00:00.000Z","updated":"2023-05-29T18:58:39.003Z","comments":true,"path":"2023/05/23/聚合搜索平台项目部署/","link":"","permalink":"https://chen28176.github.io/2023/05/23/%E8%81%9A%E5%90%88%E6%90%9C%E7%B4%A2%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"","text":"项目部署（docker部署）elasticsearch部署 因为我们还需要部署kibana容器，因此需要让elasticsearch和kibana容器互联。这里先创建一个网络： 1docker network create es-net 加载镜像，我用的elasticsearch的7.12.1版本的镜像，镜像放到网盘里了。 链接：https://pan.baidu.com/s/1WULYE5JqDFbulyFypstY8A提取码：ldqj 大家将es.tar其上传到服务器上，然后运行命令加载即可： 12# 导入数据docker load -i es.tar 3.运行docker命令,启动容器 1234567891011docker run -d \\ --name es \\ -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\ -e &quot;discovery.type=single-node&quot; \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ --privileged \\ --network es-net \\ -p 9200:9200 \\ -p 9300:9300 \\elasticsearch:7.12.1 命令解释： -e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称 -e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问 -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小 -e &quot;discovery.type=single-node&quot;：非集群模式 -v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录 -v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录 -v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录 --privileged：授予逻辑卷访问权 --network es-net ：加入一个名为es-net的网络中 -p 9200:9200：端口映射配置 kibana部署和elasticsearch部署步骤一样。 先加载镜像，**(镜像我放到了网盘里，链接在上方)** 1docker load -i es.tar 运行docker命令，部署kibana 123456docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601 \\kibana:7.12.1 --network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中 -e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch -p 5601:5601：端口映射配置 安装ik分词器 安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看: 1docker volume inspect es-plugins 显示结果： 1234567891011[ &#123; &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;, &quot;Name&quot;: &quot;es-plugins&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 说明plugins目录被挂载到了：/var/lib/docker/volumes/es-plugins/_data 这个目录中。 在本地解压ik分词器压缩包，重命名为ik（压缩包放到了网盘，链接在上方） 上传到es容器的插件数据卷中，也就是/var/lib/docker/volumes/es-plugins/_data 重启容器 12# 4、重启容器docker restart es 12# 查看es日志docker logs -f es 前端项目部署打包后,直接部署到nginx上，server配置如下 1234567891011121314151617server &#123; listen 8000; server_name localhost; include enable-php.conf; location / &#123; root search-frontend/dist; # 你的dist存放的目录 index index.html index.htm; try_files $uri /index.html; &#125; location /api &#123; proxy_pass http://locahost:8101; #你的后端的地址 &#125; &#125; 后端项目部署 编写Dockerfile文件 1234FROM openjdk:8COPY ./search-backend.jar /tmp/search-backend.jarEXPOSE 8101ENTRYPOINT java -jar -Duser.timezone=GMT+08 /tmp/search-backend.jar 构建镜像 1docker build -f Dockerfile -t search-backend . 运行容器 1docker run -id --name=search-backend -p 8101:8101 --add-host host.docker.internal:host-gateway search-backend 注意：如果使用docker部署，locahost访问的不是宿主机，而是容器。需要将配置文件application.yml中的 localhost 替换成 host.docker.internal 然后运行容器时添加命令： –add-host host.docker.internal:host-gateway 参考:","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"https://chen28176.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"前端开发保存路由的方法","slug":"前端开发保存页面状态","date":"2023-05-22T10:00:00.000Z","updated":"2023-05-29T19:04:31.176Z","comments":true,"path":"2023/05/22/前端开发保存页面状态/","link":"","permalink":"https://chen28176.github.io/2023/05/22/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BF%9D%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81/","excerpt":"","text":"前端开发用url记录搜索状态，当页面刷新时，能够从url还原之前的搜索状态 技巧:把同步状态改成单项，运行url来改变页面状态，不允许反向 1，让用户在操作的时候，改变url地址（点击搜索框，搜索内容填充到url上?,切换tab时，也要填充） 2，当页面刷新url改变的时候，去改变页面状态（监听url的改变） IndexPage.vue 核心代码 1234567891011121314151617181920212223242526272829303132333435const router = useRouter();const route = useRoute();const activeKey = route.params.category;// 存储默认初始值const initSearchParams = &#123; text: &quot;&quot;, //搜索的参数 pageSize: 10, //页数 pageNum: 1, //页码&#125;;// 用于记录路由queryconst searchParams = ref(initSearchParams);// 搜索时触发const onSearch = () =&gt; &#123; router.push(&#123; query: searchParams.value, &#125;);&#125;;// 切换tab导航时触发const onTabChange = (key: string) =&gt; &#123; router.push(&#123; path: `/$&#123;key&#125;`, query: searchParams.value, //这里加上了query &#125;);&#125;;//当路由改变时，修改searchParamswatchEffect(() =&gt; &#123; searchParams.value = &#123; ...initSearchParams, //解构 text: route.query.text, //拿到route.query.text同步到searchParams &#125; as never;&#125;); index.ts 路由 123456789101112131415161718192021import &#123; createRouter, createWebHashHistory, RouteRecordRaw &#125; from &quot;vue-router&quot;;import IndexPage from &quot;../views/IndexPage.vue&quot;;const routes: Array&lt;RouteRecordRaw&gt; = [ &#123; path: &quot;/&quot;, component: IndexPage, &#125;, &#123; path: &quot;/:category&quot;, component: IndexPage, &#125;,];const router = createRouter(&#123; history: createWebHashHistory(), routes,&#125;);export default router;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"https://chen28176.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"运营平台配置文件笔记","slug":"硅谷甄选项目笔记","date":"2023-05-21T10:00:00.000Z","updated":"2023-05-29T18:11:08.879Z","comments":true,"path":"2023/05/21/硅谷甄选项目笔记/","link":"","permalink":"https://chen28176.github.io/2023/05/21/%E7%A1%85%E8%B0%B7%E7%94%84%E9%80%89%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"硅谷甄选运营平台一、搭建后台管理系统模板2.1项目初始化今天来带大家从0开始搭建一个vue3版本的后台管理系统。一个项目要有统一的规范，需要使用eslint+stylelint+prettier来对我们的代码质量做检测和修复，需要使用husky来做commit拦截，需要使用commitlint来统一提交规范，需要使用preinstall来统一包管理工具。 下面我们就用这一套规范来初始化我们的项目，集成一个规范的模版。 2.1.1环境准备 node v16.14.2 pnpm 8.0.0 2.1.2初始化项目本项目使用vite进行构建，vite官方中文文档参考：cn.vitejs.dev&#x2F;guide&#x2F; pnpm:performant npm ，意味“高性能的 npm”。pnpm由npm&#x2F;yarn衍生而来，解决了npm&#x2F;yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具” pnpm安装指令 1npm i -g pnpm 项目初始化命令: 1pnpm create vite 进入到项目根目录pnpm install安装全部依赖.安装完依赖运行程序:pnpm run dev 运行完毕项目跑在http://127.0.0.1:5173/,可以访问你得项目啦 2.2项目配置一、eslint配置eslint中文官网:http://eslint.cn/ ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具 首先安装eslint 1pnpm i eslint -D 生成配置文件:.eslint.cjs 1npx eslint --init .eslint.cjs配置文件 123456789101112131415161718192021222324252627282930313233343536373839module.exports = &#123; //运行环境 &quot;env&quot;: &#123; &quot;browser&quot;: true,//浏览器端 &quot;es2021&quot;: true,//es2021 &#125;, //规则继承 &quot;extends&quot;: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key &quot;eslint:recommended&quot;, //vue3语法规则 &quot;plugin:vue/vue3-essential&quot;, //ts语法规则 &quot;plugin:@typescript-eslint/recommended&quot; ], //要为特定类型的文件指定处理器 &quot;overrides&quot;: [ ], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, //指定解析器选项 &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: &quot;latest&quot;,//校验ECMA最新版本 &quot;sourceType&quot;: &quot;module&quot;//设置为&quot;script&quot;（默认），或者&quot;module&quot;代码在ECMAScript模块中 &#125;, //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 &quot;plugins&quot;: [ &quot;vue&quot;, &quot;@typescript-eslint&quot; ], //eslint规则 &quot;rules&quot;: &#123; &#125;&#125; 1.1vue3环境代码校验插件12345678910# 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查&quot;eslint-config-prettier&quot;: &quot;^8.6.0&quot;,&quot;eslint-plugin-import&quot;: &quot;^2.27.5&quot;,&quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,# 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低&quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;,# vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南&quot;eslint-plugin-vue&quot;: &quot;^9.9.0&quot;,# 该解析器允许使用Eslint校验所有babel code&quot;@babel/eslint-parser&quot;: &quot;^7.19.1&quot;, 安装指令 1pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 1.2修改.eslintrc.cjs配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// @see https://eslint.bootcss.com/docs/rules/module.exports = &#123; env: &#123; browser: true, es2021: true, node: true, jest: true, &#125;, /* 指定如何解析语法 */ parser: &#x27;vue-eslint-parser&#x27;, /** 优先级低于 parse 的语法解析配置 */ parserOptions: &#123; ecmaVersion: &#x27;latest&#x27;, sourceType: &#x27;module&#x27;, parser: &#x27;@typescript-eslint/parser&#x27;, jsxPragma: &#x27;React&#x27;, ecmaFeatures: &#123; jsx: true, &#125;, &#125;, /* 继承已有的规则 */ extends: [ &#x27;eslint:recommended&#x27;, &#x27;plugin:vue/vue3-essential&#x27;, &#x27;plugin:@typescript-eslint/recommended&#x27;, &#x27;plugin:prettier/recommended&#x27;, ], plugins: [&#x27;vue&#x27;, &#x27;@typescript-eslint&#x27;], /* * &quot;off&quot; 或 0 ==&gt; 关闭规则 * &quot;warn&quot; 或 1 ==&gt; 打开的规则作为警告（不影响代码执行） * &quot;error&quot; 或 2 ==&gt; 规则作为一个错误（代码不能执行，界面报错） */ rules: &#123; // eslint（https://eslint.bootcss.com/docs/rules/） &#x27;no-var&#x27;: &#x27;error&#x27;, // 要求使用 let 或 const 而不是 var &#x27;no-multiple-empty-lines&#x27;: [&#x27;warn&#x27;, &#123; max: 1 &#125;], // 不允许多个空行 &#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;, &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;, &#x27;no-unexpected-multiline&#x27;: &#x27;error&#x27;, // 禁止空余的多行 &#x27;no-useless-escape&#x27;: &#x27;off&#x27;, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) &#x27;@typescript-eslint/no-unused-vars&#x27;: &#x27;error&#x27;, // 禁止定义未使用的变量 &#x27;@typescript-eslint/prefer-ts-expect-error&#x27;: &#x27;error&#x27;, // 禁止使用 @ts-ignore &#x27;@typescript-eslint/no-explicit-any&#x27;: &#x27;off&#x27;, // 禁止使用 any 类型 &#x27;@typescript-eslint/no-non-null-assertion&#x27;: &#x27;off&#x27;, &#x27;@typescript-eslint/no-namespace&#x27;: &#x27;off&#x27;, // 禁止使用自定义 TypeScript 模块和命名空间。 &#x27;@typescript-eslint/semi&#x27;: &#x27;off&#x27;, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) &#x27;vue/multi-word-component-names&#x27;: &#x27;off&#x27;, // 要求组件名称始终为 “-” 链接的单词 &#x27;vue/script-setup-uses-vars&#x27;: &#x27;error&#x27;, // 防止&lt;script setup&gt;使用的变量&lt;template&gt;被标记为未使用 &#x27;vue/no-mutating-props&#x27;: &#x27;off&#x27;, // 不允许组件 prop的改变 &#x27;vue/attribute-hyphenation&#x27;: &#x27;off&#x27;, // 对模板中的自定义组件强制执行属性命名样式 &#125;,&#125; 1.3.eslintignore忽略文件12distnode_modules 1.4运行脚本package.json新增两个运行脚本 1234&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint src&quot;, &quot;fix&quot;: &quot;eslint src --fix&quot;,&#125; 二、配置prettier有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次； 而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持 包含js在内的多种语言。 总结起来，eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。 2.1安装依赖包1pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 2.2.prettierrc.json添加规则123456789&#123; &quot;singleQuote&quot;: true, &quot;semi&quot;: false, &quot;bracketSpacing&quot;: true, &quot;htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;, &quot;endOfLine&quot;: &quot;auto&quot;, &quot;trailingComma&quot;: &quot;all&quot;, &quot;tabWidth&quot;: 2&#125; 2.3.prettierignore忽略文件1234567/dist/*/html/*.local/node_modules/****/*.svg**/*.sh/public/* 通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix 修改 三、配置stylelintstylelint为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。 我们的项目中使用scss作为预处理器，安装以下依赖： 1pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 3.1.stylelintrc.cjs配置文件官网:https://stylelint.bootcss.com/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// @see https://stylelint.bootcss.com/module.exports = &#123; extends: [ &#x27;stylelint-config-standard&#x27;, // 配置stylelint拓展插件 &#x27;stylelint-config-html/vue&#x27;, // 配置 vue 中 template 样式格式化 &#x27;stylelint-config-standard-scss&#x27;, // 配置stylelint scss插件 &#x27;stylelint-config-recommended-vue/scss&#x27;, // 配置 vue 中 scss 样式格式化 &#x27;stylelint-config-recess-order&#x27;, // 配置stylelint css属性书写顺序插件, &#x27;stylelint-config-prettier&#x27;, // 配置stylelint和prettier兼容 ], overrides: [ &#123; files: [&#x27;**/*.(scss|css|vue|html)&#x27;], customSyntax: &#x27;postcss-scss&#x27;, &#125;, &#123; files: [&#x27;**/*.(html|vue)&#x27;], customSyntax: &#x27;postcss-html&#x27;, &#125;, ], ignoreFiles: [ &#x27;**/*.js&#x27;, &#x27;**/*.jsx&#x27;, &#x27;**/*.tsx&#x27;, &#x27;**/*.ts&#x27;, &#x27;**/*.json&#x27;, &#x27;**/*.md&#x27;, &#x27;**/*.yaml&#x27;, ], /** * null =&gt; 关闭该规则 * always =&gt; 必须 */ rules: &#123; &#x27;value-keyword-case&#x27;: null, // 在 css 中使用 v-bind，不报错 &#x27;no-descending-specificity&#x27;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 &#x27;function-url-quotes&#x27;: &#x27;always&#x27;, // 要求或禁止 URL 的引号 &quot;always(必须加上引号)&quot;|&quot;never(没有引号)&quot; &#x27;no-empty-source&#x27;: null, // 关闭禁止空源码 &#x27;selector-class-pattern&#x27;: null, // 关闭强制选择器类名的格式 &#x27;property-no-unknown&#x27;: null, // 禁止未知的属性(true 为不允许) &#x27;block-opening-brace-space-before&#x27;: &#x27;always&#x27;, //大括号之前必须有一个空格或不能有空白符 &#x27;value-no-vendor-prefix&#x27;: null, // 关闭 属性值前缀 --webkit-box &#x27;property-no-vendor-prefix&#x27;: null, // 关闭 属性前缀 -webkit-mask &#x27;selector-pseudo-class-no-unknown&#x27;: [ // 不允许未知的选择器 true, &#123; ignorePseudoClasses: [&#x27;global&#x27;, &#x27;v-deep&#x27;, &#x27;deep&#x27;], // 忽略属性，修改element默认样式的时候能使用到 &#125;, ], &#125;,&#125; 3.2.stylelintignore忽略文件1234/node_modules/*/dist/*/html/*/public/* 3.3运行脚本123&quot;scripts&quot;: &#123; &quot;lint:style&quot;: &quot;stylelint src/**/*.&#123;css,scss,vue&#125; --cache --fix&quot;&#125; 最后配置统一的prettier来格式化我们的js和css，html代码 12345678910&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite --open&quot;, &quot;build&quot;: &quot;vue-tsc &amp;&amp; vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot;, &quot;lint&quot;: &quot;eslint src&quot;, &quot;fix&quot;: &quot;eslint src --fix&quot;, &quot;format&quot;: &quot;prettier --write \\&quot;./**/*.&#123;html,vue,ts,js,json,md&#125;\\&quot;&quot;, &quot;lint:eslint&quot;: &quot;eslint src/**/*.&#123;ts,vue&#125; --cache --fix&quot;, &quot;lint:style&quot;: &quot;stylelint src/**/*.&#123;css,scss,vue&#125; --cache --fix&quot; &#125;, 当我们运行pnpm run format的时候，会把代码直接格式化 四、配置husky在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。 要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。 安装husky 1pnpm install -D husky 执行 1npx husky-init 会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行 在.husky/pre-commit文件添加如下命令： 123#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;pnpm run format 当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。 五、配置commitlint对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。 安装包 1pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置文件，新建commitlint.config.cjs(注意是cjs)，然后添加下面的代码： 1234567891011121314151617181920212223242526272829module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;], // 校验规则 rules: &#123; &#x27;type-enum&#x27;: [ 2, &#x27;always&#x27;, [ &#x27;feat&#x27;, &#x27;fix&#x27;, &#x27;docs&#x27;, &#x27;style&#x27;, &#x27;refactor&#x27;, &#x27;perf&#x27;, &#x27;test&#x27;, &#x27;chore&#x27;, &#x27;revert&#x27;, &#x27;build&#x27;, ], ], &#x27;type-case&#x27;: [0], &#x27;type-empty&#x27;: [0], &#x27;scope-empty&#x27;: [0], &#x27;scope-case&#x27;: [0], &#x27;subject-full-stop&#x27;: [0, &#x27;never&#x27;], &#x27;subject-case&#x27;: [0, &#x27;never&#x27;], &#x27;header-max-length&#x27;: [0, &#x27;always&#x27;, 72], &#125;,&#125; 在package.json中配置scripts命令 123456# 在scrips中添加下面的代码&#123;&quot;scripts&quot;: &#123; &quot;commitlint&quot;: &quot;commitlint --config commitlint.config.cjs -e -V&quot; &#125;,&#125; 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject 12345678910&#x27;feat&#x27;,//新特性、新功能&#x27;fix&#x27;,//修改bug&#x27;docs&#x27;,//文档修改&#x27;style&#x27;,//代码格式修改, 注意不是 css 修改&#x27;refactor&#x27;,//代码重构&#x27;perf&#x27;,//优化相关，比如提升性能、体验&#x27;test&#x27;,//测试用例修改&#x27;chore&#x27;,//其他修改, 比如改变构建流程、或者增加依赖库、工具等&#x27;revert&#x27;,//回滚到上一个版本&#x27;build&#x27;,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置husky 1npx husky add .husky/commit-msg 在生成的commit-msg文件中添加下面的命令 123#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;pnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m ‘fix: xxx’ 符合类型的才可以，需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的 六、强制使用pnpm包管理器工具团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样, 导致项目出现bug问题,因此包管理器工具需要统一管理！！！ 在根目录创建scritps/preinstall.js文件，添加下面的内容 1234567if (!/pnpm/.test(process.env.npm_execpath || &#x27;&#x27;)) &#123; console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m\\n`, ) process.exit(1)&#125; 配置命令 123&quot;scripts&quot;: &#123; &quot;preinstall&quot;: &quot;node ./scripts/preinstall.js&quot;&#125; 当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。 二、项目集成3.1集成element-plus硅谷甄选运营平台,UI组件库采用的element-plus，因此需要集成element-plus插件！！！ 官网地址:https://element-plus.gitee.io/zh-CN/ 1pnpm install element-plus @element-plus/icons-vue 入口文件main.ts全局安装element-plus,element-plus默认支持语言英语设置为中文 1234567import ElementPlus from &#x27;element-plus&#x27;;import &#x27;element-plus/dist/index.css&#x27;//@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败)import zhCn from &#x27;element-plus/dist/locale/zh-cn.mjs&#x27;app.use(ElementPlus, &#123; locale: zhCn&#125;) Element Plus全局组件类型声明 1234567// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; // ... &quot;types&quot;: [&quot;element-plus/global&quot;] &#125;&#125; 配置完毕可以测试element-plus组件与图标的使用. 3.2src别名的配置在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名！！！ 123456789101112// vite.config.tsimport &#123;defineConfig&#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;export default defineConfig(&#123; plugins: [vue()], resolve: &#123; alias: &#123; &quot;@&quot;: path.resolve(&quot;./src&quot;) // 相对路径别名配置，使用 @ 代替 src &#125; &#125;&#125;) TypeScript 编译配置 123456789// tsconfig.json&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录 &quot;paths&quot;: &#123; //路径映射，相对于baseUrl &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;&#125; 3.3环境变量的配置项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。 开发环境（development）顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。 测试环境（testing）测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试 生产环境（production）生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。) 注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！ 项目根目录分别添加 开发、生产和测试环境的文件! 123.env.development.env.production.env.test 文件内容 1234# 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = &#x27;development&#x27;VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;VITE_APP_BASE_API = &#x27;/dev-api&#x27; 123NODE_ENV = &#x27;production&#x27;VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;VITE_APP_BASE_API = &#x27;/prod-api&#x27; 1234# 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = &#x27;test&#x27;VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;VITE_APP_BASE_API = &#x27;/test-api&#x27; 配置运行命令：package.json 123456&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite --open&quot;, &quot;build:test&quot;: &quot;vue-tsc &amp;&amp; vite build --mode test&quot;, &quot;build:pro&quot;: &quot;vue-tsc &amp;&amp; vite build --mode production&quot;, &quot;preview&quot;: &quot;vite preview&quot; &#125;, 通过import.meta.env获取环境变量 3.4SVG图标配置在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源, 这对页面性能来说是个很大的提升，而且我们SVG文件比img要小的很多，放在项目中几乎不占用资源。 安装SVG依赖插件 1pnpm install vite-plugin-svg-icons -D 在vite.config.ts中配置插件 1234567891011121314import &#123; createSvgIconsPlugin &#125; from &#x27;vite-plugin-svg-icons&#x27;import path from &#x27;path&#x27;export default () =&gt; &#123; return &#123; plugins: [ createSvgIconsPlugin(&#123; // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), &#x27;src/assets/icons&#x27;)], // Specify symbolId format symbolId: &#x27;icon-[dir]-[name]&#x27;, &#125;), ], &#125;&#125; 入口文件导入 1import &#x27;virtual:svg-icons-register&#x27; 3.4.1svg封装为全局组件因为项目很多模块需要使用图标,因此把它封装为全局组件！！！ 在src&#x2F;components目录下创建一个SvgIcon组件:代表如下 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;svg :style=&quot;&#123; width: width, height: height &#125;&quot;&gt; &lt;use :xlink:href=&quot;prefix + name&quot; :fill=&quot;color&quot;&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;defineProps(&#123; //xlink:href属性值的前缀 prefix: &#123; type: String, default: &#x27;#icon-&#x27; &#125;, //svg矢量图的名字 name: String, //svg图标的颜色 color: &#123; type: String, default: &quot;&quot; &#125;, //svg宽度 width: &#123; type: String, default: &#x27;16px&#x27; &#125;, //svg高度 height: &#123; type: String, default: &#x27;16px&#x27; &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在src文件夹目录下创建一个index.ts文件：用于注册components文件夹内部全部全局组件！！！ 12345678910import SvgIcon from &#x27;./SvgIcon/index.vue&#x27;;import type &#123; App, Component &#125; from &#x27;vue&#x27;;const components: &#123; [name: string]: Component &#125; = &#123; SvgIcon &#125;;export default &#123; install(app: App) &#123; Object.keys(components).forEach((key: string) =&gt; &#123; app.component(key, components[key]); &#125;) &#125;&#125; 在入口文件引入src&#x2F;index.ts文件,通过app.use方法安装自定义插件 12import gloablComponent from &#x27;./components/index&#x27;;app.use(gloablComponent); 3.5集成sass我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang&#x3D;”scss” 1&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; 接下来我们为项目添加一些全局的样式 在src&#x2F;styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss 1@import reset.scss 在入口文件引入 1import &#x27;@/styles&#x27; 但是你会发现在src&#x2F;styles&#x2F;index.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$. 在style&#x2F;variable.scss创建一个variable.scss文件！ 在vite.config.ts文件配置如下: 1234567891011export default defineConfig((config) =&gt; &#123; css: &#123; preprocessorOptions: &#123; scss: &#123; javascriptEnabled: true, additionalData: &#x27;@import &quot;./src/styles/variable.scss&quot;;&#x27;, &#125;, &#125;, &#125;, &#125;&#125; @import &quot;./src/styles/variable.less&quot;;后面的;不要忘记，不然会报错! 配置完毕你会发现scss提供这些全局变量可以在组件样式中使用了！！！ 3.6mock数据安装依赖:https://www.npmjs.com/package/vite-plugin-mock 1pnpm install -D vite-plugin-mock mockjs 在 vite.config.js 配置文件启用插件。 12345678910111213import &#123; UserConfigExport, ConfigEnv &#125; from &#x27;vite&#x27;import &#123; viteMockServe &#125; from &#x27;vite-plugin-mock&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;export default (&#123; command &#125;)=&gt; &#123; return &#123; plugins: [ vue(), viteMockServe(&#123; localEnabled: command === &#x27;serve&#x27;, &#125;), ], &#125;&#125; 在根目录创建mock文件夹:去创建我们需要mock数据与接口！！！ 在mock文件夹内部创建一个user.ts文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//用户信息数据function createUserList() &#123; return [ &#123; userId: 1, avatar: &#x27;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&#x27;, username: &#x27;admin&#x27;, password: &#x27;111111&#x27;, desc: &#x27;平台管理员&#x27;, roles: [&#x27;平台管理员&#x27;], buttons: [&#x27;cuser.detail&#x27;], routes: [&#x27;home&#x27;], token: &#x27;Admin Token&#x27;, &#125;, &#123; userId: 2, avatar: &#x27;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&#x27;, username: &#x27;system&#x27;, password: &#x27;111111&#x27;, desc: &#x27;系统管理员&#x27;, roles: [&#x27;系统管理员&#x27;], buttons: [&#x27;cuser.detail&#x27;, &#x27;cuser.user&#x27;], routes: [&#x27;home&#x27;], token: &#x27;System Token&#x27;, &#125;, ]&#125;export default [ // 用户登录接口 &#123; url: &#x27;/api/user/login&#x27;,//请求地址 method: &#x27;post&#x27;,//请求方式 response: (&#123; body &#125;) =&gt; &#123; //获取请求体携带过来的用户名与密码 const &#123; username, password &#125; = body; //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) =&gt; item.username === username &amp;&amp; item.password === password, ) //没有用户返回失败信息 if (!checkUser) &#123; return &#123; code: 201, data: &#123; message: &#x27;账号或者密码不正确&#x27; &#125; &#125; &#125; //如果有返回成功信息 const &#123; token &#125; = checkUser return &#123; code: 200, data: &#123; token &#125; &#125; &#125;, &#125;, // 获取用户信息 &#123; url: &#x27;/api/user/info&#x27;, method: &#x27;get&#x27;, response: (request) =&gt; &#123; //获取请求头携带token const token = request.headers.token; //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) =&gt; item.token === token) //没有返回失败的信息 if (!checkUser) &#123; return &#123; code: 201, data: &#123; message: &#x27;获取用户信息失败&#x27; &#125; &#125; &#125; //如果有返回成功信息 return &#123; code: 200, data: &#123;checkUser&#125; &#125; &#125;, &#125;,] 安装axios 1pnpm install axios 最后通过axios测试接口！！！ 3.7axios二次封装在开发项目的时候避免不了与后端进行交互,因此我们需要使用axios插件实现发送网络请求。在开发项目的时候 我们经常会把axios进行二次封装。 目的: 1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数) 2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误) 在根目录下创建utils&#x2F;request.ts 123456789101112131415161718192021222324252627282930313233343536373839404142import axios from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;//创建axios实例let request = axios.create(&#123; baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000&#125;)//请求拦截器request.interceptors.request.use(config =&gt; &#123; return config;&#125;);//响应拦截器request.interceptors.response.use((response) =&gt; &#123; return response.data;&#125;, (error) =&gt; &#123; //处理网络错误 let msg = &#x27;&#x27;; let status = error.response.status; switch (status) &#123; case 401: msg = &quot;token过期&quot;; break; case 403: msg = &#x27;无权访问&#x27;; break; case 404: msg = &quot;请求地址错误&quot;; break; case 500: msg = &quot;服务器出现问题&quot;; break; default: msg = &quot;无网络&quot;; &#125; ElMessage(&#123; type: &#x27;error&#x27;, message: msg &#125;) return Promise.reject(error);&#125;);export default request; 3.8API接口统一管理在开发项目的时候,接口可能很多需要统一管理。在src目录下去创建api文件夹去统一管理项目的接口； 比如:下面方式 12345678910111213141516171819202122232425262728293031323334353637//统一管理咱们项目用户相关的接口import request from &#x27;@/utils/request&#x27;import type &#123; loginFormData, loginResponseData, userInfoReponseData,&#125; from &#x27;./type&#x27;//项目用户相关的请求地址enum API &#123; LOGIN_URL = &#x27;/admin/acl/index/login&#x27;, USERINFO_URL = &#x27;/admin/acl/index/info&#x27;, LOGOUT_URL = &#x27;/admin/acl/index/logout&#x27;,&#125;//登录接口export const reqLogin = (data: loginFormData) =&gt; request.post&lt;any, loginResponseData&gt;(API.LOGIN_URL, data)//获取用户信息export const reqUserInfo = () =&gt; request.get&lt;any, userInfoReponseData&gt;(API.USERINFO_URL)//退出登录export const reqLogout = () =&gt; request.post&lt;any, any&gt;(API.LOGOUT_URL)","categories":[{"name":"后台管理项目","slug":"后台管理项目","permalink":"https://chen28176.github.io/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"Hello","slug":"介绍","date":"2023-05-20T10:00:00.000Z","updated":"2023-05-29T19:04:26.621Z","comments":true,"path":"2023/05/20/介绍/","link":"","permalink":"https://chen28176.github.io/2023/05/20/%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"这白开水怎么没味啊","categories":[{"name":"介绍","slug":"介绍","permalink":"https://chen28176.github.io/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[]}],"categories":[{"name":"后台管理项目","slug":"后台管理项目","permalink":"https://chen28176.github.io/categories/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"name":"番剧推荐","slug":"番剧推荐","permalink":"https://chen28176.github.io/categories/%E7%95%AA%E5%89%A7%E6%8E%A8%E8%8D%90/"},{"name":"前端笔记","slug":"前端笔记","permalink":"https://chen28176.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"},{"name":"介绍","slug":"介绍","permalink":"https://chen28176.github.io/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[]}